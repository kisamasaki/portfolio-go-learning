# 『初めてのGo言語』
- goはコンパイル言語
    - バイナリファイルが作られる
    - go runコマンドで一時ディレクトリに置かれ、プログラム終了後に削除される
- コンパイルのメリット
    - 機械語やバイナリコードに変換して実行可能なプログラムを生成
    - 型の不一致に起因するエラーをコンパイル時に検出可能
    - 機械語に変換されているため、通常は高い実行速度を提供する
- パッケージ
    - 関連するソースコードがまとめられたファイルの集まり
- モジュール
    - プロジェクトの依存関係を管理し、コードのバージョン管理を補助する仕組み
    - go.mod ファイルによって定義され、バージョンなどの情報が記述されている
- 依存関係
    - 外部ライブラリやモジュールに対するプロジェクトの依存性
- 配列には制限があるため直接使われることは多くない
- 一連の値を保持する為のデータ構造が必要ならば殆どの場合可変長の配列とも言えるスライスを使うのが正解
- go言語は値呼び出しの言語
    - 関数に渡される引数が実際にはその値のコピーが渡されることを意味する。関数内で引数の値を変更しても、呼び出し元の変数には影響がない。
- appendを使用した場合、元のスライスが参照している配列の容量が足りない場合、新しいメモリ領域が確保され、既存の要素と新しい要素が新しいメモリにコピーされる。この操作によって元のスライスが更新されるのではなく、新しいスライスが新しいメモリを指すようになります。
- appendの戻り値を変数に代入せず無視するとコンパイル時にエラー
- capはスライスの現在のキャパシティを返す。新しいデータを保持するのに十分なサイズがあるか確認したい場合はcapが使える
- appendによってスライスが大きくなってくるとコピーの為に時間がかかるようになる。予め最大のサイズが分かっているならばmakeを指定した方が効率的
- appendを使用してスライスに要素を追加した際、元の配列が不要になる場合、ガベージコレクタがそれを検出してメモリを解放します。
- スライスからサブスライスを切り出すときは注意する必要がある。親スライスもサブスライスも同じメモリ領域を共有し一方の変更はもう一方に影響を及ぼす。サブスライスを作ったらオリジナルのスライスもサブスライスも変更は避けた方が無難。appendでは複数のスライスがキャパシティを共有しないようフルスライス式を使う。
- スライスマップは参照型
- スライスxをスライスして別のスライスyを作ると、スライスxで使われていなかったキャパシティもスライスyと共有されてしまう。
    - この場合、複数のスライスが他のスライスのデータをappendしたり上書きする。
    - こうした状況を避けるにはサブスライスのキャパシティとサブスライスの長さを同じにすることで、要素追加時に他のスライスと共有無しに新しいスライスを作ることが可能。
- オリジナルとはメモリを共有しない独立したスライスを生成する必要があるのならばmakeと組み込みの関数copyを使う。
- Go言語では文字列を関数lenに渡して文字列の長さが返されるが値はバイト数になる。
```go
// 要素を加えることが出来ない
var nilMap map[string]int

// 読み書き療法可能
totalWins := map[string]int{}
```
- Goではifの本体は短くすることが推奨される
```go
package main

import "fmt"

func main() {
	for i := 1; i <= 100; i++ {
		if i%3 == 0 {
			if i%5 == 0 {
				fmt.Println(i, "3でも5でも割り切れる")
			} else {
				fmt.Println(i, "3で割り切れる")
			}
		} else if i%5 == 0 {
			fmt.Println(i, "5で割り切れる")
		} else {
			fmt.Println(i)
		}
	}
}
```
上記ではなく下記の書き方を行う。
```go
package main

import "fmt"

func main() {
	for i := 1; i <= 100; i++ {
		if i%3 == 0 && i%5 == 0 {
			fmt.Println(i, "3でも5でも割り切れる")
			continue
		}
		if i%3 == 0 {
			fmt.Println(i, "3で割り切れる")
			continue
		}
		if i%5 == 0 {
			fmt.Println(i, "5で割り切れる")
			continue
		}
		fmt.Println(i)
	}
}
```
- for-rangeを使用してイテレーションする場合、通常は要素のコピーが作成される。
```go
numbers := []int{1, 2, 3, 4, 5}

for _, num := range numbers {
    num *= 2  // numは元の要素のコピー
    fmt.Println(num)
}

fmt.Println(numbers)  // 元のスライスは変わっていない
```
元のスライスの要素自体を変更したい場合は、添え字を使って直接要素にアクセスするか、ポインタを使用して要素への参照を取得して操作する必要がある
```go
numbers := []int{1, 2, 3, 4, 5}

for i := range numbers {
    numbers[i] *= 2  // numbers[i]は元の要素への参照
}

fmt.Println(numbers)  // 元のスライスが変更されている
```
- ラベルを使用した場合、breakでは外側のforループが一気に終了し、continueを使用した場合、内側のforループがスキップされ、外側のforループの次の繰り返しに進む。
- for-rangeで最初の2番目から最後の2番目まで処理したい場合は、continueやbreakを使用するよりも下記の方が短くて理解しやすい
```go
package main

import "fmt"

func main() {
	evenVals := []int{2, 4, 6, 8, 10}
	for i := 1; i < len(evenVals)-1; i++ {
		fmt.Println(i, evenVals[i])
	}
}
```
- 名前付き戻り値はdeferで使用する。プログラムの説明になるという理由で好まれる場合もあるが、関数の外側でも変数が使われる場合に可読性が低下する。
- 関数が値を返すならブランクreturnは絶対に使ってはならない。返される値が分かりにくくなるから。
- Goにはカンマokイディオムがあり、下記実装で値と真偽値が返る。
```go
v, ok := m["hello"]
```
- "ダックタイピング" という用語は、「もしアヒルのように歩いて、鳴いて、アヒルのように見えるなら、それはアヒルだ」というアナロジーに由来している。具体的な型の名前よりも、その型の振る舞いが重要であるという考え方。型の名前に依存せず、代わりに振る舞いに焦点を当てるため、柔軟性がある
```go
package main

import "fmt"

// Quacker インターフェース
type Quacker interface {
	Quack()
}

// Duck 型
type Duck struct{}

// Duck 型が Quacker インターフェースを実装
func (d Duck) Quack() {
	fmt.Println("Quack!")
}

// Dog 型
type Dog struct{}

// Dog 型が Quacker インターフェースを実装
func (d Dog) Quack() {
	fmt.Println("Woof!")
}

func makeSomeNoise(q Quacker) {
	q.Quack()
}

func main() {
	duck := Duck{}
	dog := Dog{}

	makeSomeNoise(duck) // Duck 型は Quacker インターフェースを実装している
	makeSomeNoise(dog)  // Dog 型も Quacker インターフェースを実装している
}
```
- *を用いてそのポインタが参照するアドレスに保存されている値を返すことをデリファレンスと呼ぶ
- nilポインタをデリファレンスしようとするとパニックにあるのでnilでないことを確認する必要がある。
- 基本型のポイントが必要な場合はまず基本型の変数を宣言し、それから参照するポインタ変数を宣言する
```go
var y string
z := &y
```
下記構造体のフィールドに直接代入は出来ないので、回避するには変数を作る必要がある。
```go
	type person struct {
		FirstName  string
		MiddleName *string
		LastName   string
	}
	
	p := person{
		FirstName:  "Pat",
		MiddleName: "Perry",  // ←コンパイル時のエラー
		LastName:   "Peterson",
	}
```
または下記ポインタ型を返却する関数を実装する。
```go
func stringp(s string) *string {
    return &s
}
```
- 定数（const）と型（type）はコンパイル時にのみ存在し、実行時にはメモリアドレスを持たない。これらはコンパイル時に解決され、実行時にはメモリ上に配置される必要が無い。
```go
const Pi = 3.14159
```
```go
type MyInt int
```
- ポインタとしてnilを渡した場合、その値をnil以外に変えることは出来ない。
- 関数にメモリのアドレスを渡した場合、そのアドレスを変えることは出来ない。
- ファイルの読み取りでforを用いてバッファとしてスライスを使う場合、一度だけバッファとして使うスライスを作成するのではなく、都度新しいスライスを作成してしまうと、メモリの割り当てと解放が頻繁に発生し、非効率的な動作となる。
- Go言語は下記のようなオーバーロードは許容されない
```go
// これはGoでは許容されない
func add(a, b int) int {
    return a + b
}

func add(a, b float64) float64 {
    return a + b
}
```
- 埋め込みフィールドは、型に別の型に埋め込むこと
    - 埋め込みフィールドで宣言されているフィールドやメソッドはそれを埋め込んでいる上位の構造体に「昇格」し、その構造体から直接呼び出せる。
    - 同名のフィールドやメソッドがある場合は埋め込まれている方が隠されるので、埋め込まれているフィールドの型を明示する必要がある
```go
type Inner struct {
	X int
}

type Outer struct {
	Inner
	X int
}

func main() {
	o := Outer{
		Inner: Inner{
			X: 10,
		},
		X: 20,
	}
	fmt.Println(o.X)       // 20
	fmt.Println(o.Inner.X) // 10
}
```
- C#ではインターフェースをクラスに明示的に実装を宣言するが、Go言語ではインターフェースが暗黙的に実装される。
    - C#ではインターフェースを実装するクラスはその実装を明示的に宣言し、具体的なメソッドがどのように実装されているかが分かる。
    - この明示性により、クラスの実装やインターフェースの使用がより透明になる。
    - C#では既存のクラスに新しいメソッドを追加する場合、そのクラスを変更する必要があるが、Goでは既存のクラスを変更することなく新しい機能を追加できる。
- 型アサーション
    - インターフェースの元になっている具体的な値を利用
- 型switch	
    - インターフェース型の変数を指定し、新しい変数へ派生させる
- それ以外の型が使える可能性を求めるべきではないことから型アサーションと型switchは頻繁に使用すべきではない
	- 具象型の裏にあるインターフェースが別のインターフェースを実装しているかチェックする場合に使用される。
		- チェックを行い、実装されていれば、関数内の作業をスキップすることが出来るから
- Goのソースコードの集合がモジュール
- go getコマンドを使用すると依存関係にあるモジュールのバージョンを変更できる
- selectを使用することでデッドロックを回避することが出来る
- for-selectループにdefaultがあるのは正しいプログラムではない可能性が高い。ループでいつもdefaultが実行されてしまい、forループが回ることがある。
- 関数型に関数を代入するには、関数リテラルを使用して、変数に関数を代入することが一般的
```go
package main

import "fmt"

// 関数型の定義
type MyFunction func(int) int

// 関数1
func addOne(x int) int {
    return x + 1
}

func main() {
    // 関数型の変数を宣言し、関数を代入
    myFunc := MyFunction(addOne)

    // 代入した関数を使用
    result := myFunc(5)
    fmt.Println(result) // 出力: 6
}
```
- 下記実装で出力しても共にtrue表示される。これはgenErrがゼロ値として初期化されるため。解決するにはnilをreturnするかgenErrをerror型とする。
```go
package main

import (
	"fmt"
)

type Status int  //liststart1

const (  // iotaについては「7.2.7 iotaと列挙型」参照
	InvalidLogin Status = iota + 1  // 不正なログイン
	NotFound  // 見つからない
) //listend1

type StatusErr struct {  //liststart2
	Status  Status // 状態
	Message string // メッセージ
}

func (se StatusErr) Error() string {
	return se.Message
} //listend2

func GenerateError(flag bool) error { //liststart3
	var genErr StatusErr
	if flag {
		genErr = StatusErr{
			Status: NotFound,
		}
	}
	return genErr
}

func main() {
	err := GenerateError(true)
	fmt.Println(err != nil)
	err = GenerateError(false)
	fmt.Println(err != nil)
} //listend3
```
- errors.Unwrap は、Go言語の errors パッケージに含まれる関数で、エラーチェーンを構築したり、元のエラーを取り出すための機能を提供している。これを使うことで、複数のエラー情報を含むエラーチェーンを作成し、最終的なエラーから元のエラーまで順にたどることが可能。
- 特定のインスタンス、特定の値を探しているときはerrors.Isを使う。
- 特定の型を探しているときはerrors.Asを使う。
- 関数内でそれぞれのエラーにて同一のメッセージを出力する際はdeferを使うことで簡潔に実装可能。
	- この際戻り値には名前を付ける必要がある
	- 一つの戻り値に名前を付けると全てに名前を付ける必要がある
	- その場合、ほかの戻り値には「_」を指定する
- mainループでbreakを使用して途中で抜けると、ゴルーチンが終了せずにゴルーチンリークが発生することがある
```go
package main

import (
	"fmt"
	"time"
)

func countTo(max int) <-chan int { //intのチャネルを戻す
	ch := make(chan int)
	go func() {  // 無名関数
		for i := 0; i < max; i++ {
			ch <- i // 0からmax-1までの値を順にchに入れる
		}
		close(ch)
	}()

	return ch // チャネルchを戻す
}

func main() { //liststart
	for i := range countTo(10) { //countToからチャネルが戻り、0...9が代入される 
		fmt.Print(i, " ")
		if i > 5 {
			break
		}
	}
	fmt.Println()
	doSomethingTakingLongTime() // 時間のかかる処理。この間、無名関数は待ち続けている
} //listend

func doSomethingTakingLongTime() {
	time.Sleep(5*time.Second) // 何か処理をする	
}
```
- ゴルーチンリークを防止するdoneチャネルパターンがあり、ゴルーチンに対して処理を終了するべき時であることを送る
```go
func searchData(s string, searchers []func(string) []string) []string {  
	done := make(chan struct{}) // チャネルの型は空の構造体（3章参照）
	resultChan := make(chan []string)
	for _, searcher := range searchers {
		// 以下をsearchersに含まれる各関数（searcher）について行う

		// 無名関数をゴルーチンとして起動。引数は「文字列を受け取って、
		// 文字列のスライスを返す関数」
		go func(f func(string) []string) { 
			select {
			case resultChan <- f(s): // 関数の実行結果をresultChanに送る
				fmt.Println("結果が戻ってきた")
			case <-done:
				fmt.Println("doneを選択")
			}
		}(searcher)  // 無名関数の引数。関数をひとつずつ渡す
		
	} // for の終わり
	
	r := <-resultChan // 結果が返ってきたら
	close(done)   // チャネルdoneをクローズ
	return r  // 文字列のスライス
} //listend1
```
- 処理をキャンセルするためのキャンセレーション関数を戻すことでキャンセルすることも可能
```go
package main

import "fmt"

func countTo(max int) (<-chan int, func()) { //liststart
	ch := make(chan int)
	done := make(chan struct{})
	cancelFunc := func() { // chをクローズする関数を戻す
		close(done)
	}

	go func() {
		for i := 0; i < max; i++ {
			select {
			case <-done:
				return
			case ch <- i:
			}
		}
		close(ch)
	}()
	return ch, cancelFunc
}

func main() {
 	ch, cancelFunc := countTo(10)
	for i := range ch {
		if i >= 5 {  // 途中で抜けたくなったら（抜ける条件が整ったら）
			break
		}
		fmt.Print(i, " ")		
	}
	fmt.Println()
	cancelFunc() // chをクローズしてforループを終了する
} //listend
```
- クローズしたチャネルはcase文で条件がtrueになる。この為、チャネルの値をnilにすることでselectのcaseを無効化することが可能。
```go
package main

import (
	"fmt"
)

func main() {
	ch := make(chan int)
	close(ch) // チャネルをクローズする

	select {
	case v, ok := <-ch:
		fmt.Println("読み取り結果:", v, ok) // クローズされたチャネルからの読み取り
	default:
		fmt.Println("デフォルトケースが選択されました")
	}
}
```
- タイムアウトについてはtime.After関数を使用する
```go
package main

import (
	"fmt"
	"time"
)

func main() {
	// 例: 5秒のタイムアウト
	timeout := 5 * time.Second

	// タイムアウトを待つ
	select {
	case <-time.After(timeout):
		fmt.Println("タイムアウト発生")
		// タイムアウト時の処理を記述
	}
}
```
- sync.WaitGroupを関数内で使用する場合はポインタとして渡さないとカウントが正しくデクリメントされない。
- byteはuint8(符号無し8ビット)の別名だが、整数として扱っているわけではない場合はbyteとした方が意図が明確になる
- ErrorとErrorfはテストが失敗したことを残すが、テスト関数の実行は継続される。問題が生じた時点で処理を停止したい場合はFatalとFatalfを使用する。
- テストを実行する前に特定の状態を設定しておき、テストが終了したら解除する場合はTestMainを使って状態管理する
- コンテキスト（context）は並行処理や非同期処理、タイムアウト、キャンセルなどの操作を扱うための仕組み
- context.WithTimeoutは、相対時間を指定してコンテキストに制約を設定。つまり、コンテキストの有効期限は現在時刻から一定の時間後に設定。
- context.WithDeadlineは、絶対時間を指定してコンテキストに制約を設定。つまり、コンテキストの有効期限は具体的な時刻に設定。
- context.WithTimeoutは相対時間を使い、指定した時間が経過したらタイムアウトとなる。一方、context.WithDeadlineは絶対時間を使い、特定の時刻になるとタイムアウト。選択は具体的なユースケースに依存するが、通常、相対時間を使用することがより一般的。
- waitGroupはゴルーチンがすべて終了した後でクリーンアップするもの、チャネルのクローズがあるときのみ用いるべき
- syncにはOnce型があり、一度だけ実行される。once.Doだと二度以上呼ばれても実行しない
- コンテキストを生成したら、deferを使ってコンテキストのcancel関数が呼び出されるようにしないとリソースがリークする
- case <-ctx.Done():が含まれる場合、その部分がコンテキストのキャンセルやタイムアウトの監視を行っている
- sync.WaitGroupやsync.Once同様、mutexはコピーしてはいけない。関数に渡されたり構造体のフィールドとしてアクセスされたりする際には、ポインタを介さなければならない。mutexがコピーされるとロックは共有されない。
- テストを実行する前に特定の状態を設定しておき、テストが終了したらそれを解除したいという場合はTestMainを使用する。DBや外部データを設定する必要がある場合やテスト対象のコードが初期化を必要とするパッケージレベルの変数に依存する場合に使用。
- *testing.TのメソッドCleanupは生成したファイルの削除などのクリーンアップを行う場合に使用する。
- パッケージ名の最後に_testを付けることでそのパッケージをブラックボックスとして扱える。
- 比較ツールgo-cmpのcmp.Diff関数は二つの値が異なる場合、その差分を人が読みやすい形式で表示する。構造体やスライスなどの複雑なデータ構造の比較において、より細かな制御が可能であり、見やすい出力を提供。
- 繰り返しを避けるために、無名構造体のスライスを使用するテーブルテストがある。
```go
	data := []struct { //liststart2
		name     string
		num1     int
		num2     int
		op       string
		expected int
		errMsg   string
	}{
		{"addition", 2, 2, "+", 4, ""},
		{"subtraction", 2, 2, "-", 0, ""},
		{"multiplication", 2, 2, "*", 4, ""},
		{"division", 2, 2, "/", 1, ""},
		{"bad_division", 2, 0, "/", 0, `0による除算`},
		{"bad_op", 2, 2, "?", 0, `未知の演算子 ?`}, 
	} 
```
- *testing.B型のベンチマークは*testing.Tの機能を全て含む
- ベンチマークテストでは、計測したい処理をループで囲むことが一般的。for i := 0; i < b.N; i++ { } のループは、b.N回繰り返される。この中に、計測したい処理を記述しておくことで、その処理が実際にどれだけの時間やリソースを消費するかを評価することが可能。
```go
func BenchmarkExample(b *testing.B) {
    for i := 0; i < b.N; i++ {
        // ここに計測したい処理を記述
        result := SomeFunctionToBenchmark()
        _ = result
    }
}
```
- スタブは主にテストのコンテキストで使われる。スタブは、実際の機能や挙動を持たない代替の実装やオブジェクトのこと。これは、依存するコンポーネントやサービスをモックするために使用され、テストをより制御可能かつ予測可能。
- io.Seekerは、Go言語の標準パッケージであるioパッケージに定義されているインタフェースの一つ。このインタフェースは、ストリーム型のデータ（たとえばファイル、ネットワーク接続など）を対象として、読み取り・書き込み位置を変更するためのメソッドを提供。
```go
file, err := os.Open("example.txt")
if err != nil {
    log.Fatal(err)
}

// ファイル内のオフセット0に移動
offset, err := file.Seek(0, io.SeekStart)
if err != nil {
    log.Fatal(err)
}
fmt.Println("Current offset:", offset)
```
- time.Durationは、時間の長さや経過時間を表すための型
- time.Timeは、特定の瞬間を表すための型。時刻、日付、およびタイムゾーン情報を含む。
- 一度に複数のJSON構造体を読み書きする場合はjson.Marshalとjson.Unmarshalではなく、json.Decoderとjson.Encoderを使用する


# 『実用Go言語』
- Goのアプリケーションとライブラリはそれぞれモジュールと呼ばれる塊になっており、1つのフォルダが1つのモジュール
- iotaの値はコンパイル時に決まる為、途中で新しく要素が挿入されると値が変わる
    - 末尾以外に追加すると名前に対応する整数値がそれまでと変わる
- Go言語では、構造体を使用して関数にオプション引数を渡す柔軟な方法がある
    - 関数の引数が構造体である場合、未指定のフィールドはその型のゼロ値に初期化される
- 確実にリソース解放を行う為にdeferを使用できるが、Close()といったエラーを返す可能性があるケースもある。無名関数を使用し、名前付きの返り値に代入すると呼び出し元に返すことが可能。
```go
package main

import (
	"fmt"
	"io"
	"os"
)

func deferReturnSample(fname string) (err error) {
	var f *os.File
	f, err = os.Create(fname)
	if err != nil {
		return fmt.Errorf("ファイルオープンのエラー: %w", err)
	}

	// defer文内で即時エラーチェックと関数終了を行う無名関数を使用
	defer func() {
		closeErr := f.Close()
		if closeErr != nil && err == nil {
			// ファイルクローズのエラーが発生し、かつまだエラーが発生していない場合
			err = fmt.Errorf("ファイルクローズのエラー: %w", closeErr)
		}
	}()

	_, writeErr := io.WriteString(f, "deferのエラーを拾うサンプル")
	if writeErr != nil {
		// 書き込みエラーが発生した場合、即座に関数終了
		return fmt.Errorf("ファイル書き込みエラー: %w", writeErr)
	}

	return nil
}

func main() {
	err := deferReturnSample("example.txt")
	if err != nil {
		fmt.Println("エラーが発生しました:", err)
		return
	}

	fmt.Println("ファイルの書き込みとクローズが正常に行われました.")
}
```

# 『Go言語プログラミングエッセンス』
```go
n := 50
a = append(a[:n], a[n+1:]...)

n := 50
a = a[:n+copy(a[n:], a[n+1:])]
```
- スライスから要素を削除する場合はappendを使う方法、部分参照とcopyを使う方法がある。
appendを使う場合はアロケーション(新しいメモリ領域の割り当て)が発生する。
- copyを使用して元のスライス内でデータを前に詰める操作は既存のメモリ内で行われ、新しいメモリが確保されることは無い。
- Goの文字列はイミュータブルなので、一度文字列が作成されると、その内容を直接変更することはできない
    - 文字列を変更しようとすると、新しい文字列が作成され、変数がそれを参照するようになる
    - この際、元の文字列のメモリは解放されない。代わりに、新しい文字列が別のメモリ領域に確保され、変数がそのメモリ領域を指すようになる
    - バイトスライス（[]byte型）はミュータブルで、その内容を変更することができる。文字列からバイトスライスへの変換を通じて、バイトスライスを変更すると、元の文字列が指しているメモリ領域そのものが変更される
- 配列からスライスに変換するには、Go言語の組み込み関数である [:] を使用
- mapは順序を保持しない為for-rangeは毎回異なる結果となる
    - ソートされたキーで列挙したい場合は先にsort.Stringsを使用する必要がある
- 構造体のフィールドに他のパッケージから参照するには先頭を大文字にする必要がある。
    - encoding/jsonにもこのルールが適用される為、JSONに小文字は適用されない
    - 関数の引数にstructのデータを渡すとコピーが行われるので、コピーのオーバーヘッドを避けるにはポインタを使用する
- iotaを使用する際、一つのconstにまとめて記述を行うと初期値が連続するため、型ごとに宣言を別にする必要がある
- 下記実装だと、出力する際には既にループが終了している可能性があるので意図通りの結果が得られない。
```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var wg sync.WaitGroup

	for i := 0; i < 3; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			fmt.Println(i)
		}()
	}

	wg.Wait()
}
```
これを修正するためには、各ゴルーチンが異なる i の値を参照できるよう実装する。
```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var wg sync.WaitGroup

	for i := 0; i < 3; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			fmt.Println(i)
		}(i)
	}

	wg.Wait()
}
```
下記実装の場合、iの最終的な値を参照してしまう可能性がある。この問題を解決するには、iを引数として generateLargeValueに渡すことで、各ゴルーチンが異なるiの値を処理できるようにする。
```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	var wg sync.WaitGroup

	for i := 0; i < 3; i++ {
		wg.Add(1)
		go func() {
			largeValue := generateLargeValue(i) // 時間のかかる処理を含む関数
			defer wg.Done()
			fmt.Println(largeValue)
		}()
	}

	wg.Wait()
}

func generateLargeValue(i int) int {
	// 仮に時間のかかる処理を含む関数
	time.Sleep(1 * time.Second)
	return i
}
```
下記実装ではゴルーチンが同時に n をインクリメントしており、競合状態が発生している。最終的なnの値: 168047と出力される。競合状態を避けるためには、ミューテックスを使用
```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var wg sync.WaitGroup
	n := 0

	// ゴルーチン1: nをインクリメント
	wg.Add(1)
	go func() {
		defer wg.Done()
		for i := 0; i < 100000; i++ {
			n++
		}
	}()

	// ゴルーチン2: nをインクリメント
	wg.Add(1)
	go func() {
		defer wg.Done()
		for i := 0; i < 100000; i++ {
			n++
		}
	}()

	wg.Wait()

	fmt.Println("最終的なnの値:", n)
}
```
- go getコマンドはカレントディレクトリにあるgo.modを変更するがgo installはgo.modを変更しない
- printやprintlnはデバッグ用の出力で標準出力にしたい場合はfmtパッケージを使用
- ブランクimportはパッケージを明示的には使用しないがimportすることで機能を利用することを宣言する目的で使用。
	- データベースドライバの登録で使用
- Goで数値を文字列に変換するためにはstrconvパッケージを使用するがより簡単に行う方法としてfmtパッケージがある
- Go言語はStringerインターフェースを定義しており、fmtパッケージの関数によって利用されている。
```go
type Stringer interface {
    String() string
}
```
カスタム型が String メソッドを実装している場合、fmt.Println がそのメソッドを呼び出して、カスタム型の文字列表現を取得する。これにより、カスタムな表示形式でオブジェクトを表示することが可能
```go
package main

import "fmt"

type Person struct {
    Name string
    Age  int
}

func (p Person) String() string {
    return fmt.Sprintf("%s (%d years old)", p.Name, p.Age)
}

func main() {
    person := Person{"John", 30}
    fmt.Println(person)
}
```
- Goのstructにタグというメタ情報を付与することで小文字のJSONも扱えるようになる
- json.Unmarshal は、与えられた JSON データ全体をメモリに読み込み、その後構造体に変換する
- json.NewDecoder と Decoder.Decode を使用すると、JSON データを逐次的に処理できる
- timeパッケージのDurationという型は時刻ではなく型を保持できる
- pathパッケージはURLなどの仮想的なパスを扱う場合に使う
- path/filepathは物理的なパスを扱う場合に使う
- Go言語のビルド制約（build constraints）は、Goのコンパイラに対してソースコードのビルド時に特定の条件に基づいてコンパイルするための仕組み。
	- ビルド制約は、ソースコード内に埋め込まれた特定のコメントで指定される。
	- ビルド制約は、OR（||）やAND（,）などの複数の条件を組み合わせて使用することも可能。
	- 特定のオペレーティングシステムやアーキテクチャに対してのみコンパイルする場合、次のように書くこと可能。LinuxとDarwin (macOS) の環境でのみビルドすることを示している。
```go
// +build linux darwin
```
- ビルドタグはユーザーが定義することも可能。cat.goやdog.goに対してフラグを付けてビルドすることで有効無効を切り替えられる。
- タグにはignoreがあり、go buildコマンドの対象から外される。ビルドするには直接
- go buildはディレクトリ直下のファイルがビルドされる
- go build ./...は指定したディレクトリ直下のファイルがビルドされる
- どのファイルがビルドされてどのファイルがビルドされないかはファイル名やbuild tagによって決まる
- cgoはGoからC言語を扱うための仕組み
- go:embedはファイルやディレクトリの静的な埋め込みを行うためのもの。プログラムの実行可能ファイルに静的なファイルを埋め込むことができ、ランタイム時に外部のファイルに依存せずにそれらのファイルをアクセスできるようになる

# 『Go言語100Tips』
1. 意図しない変数シャドウイング
    1. ifブロックで省略変数宣言演算子(:=)を使って変数に代入を行っても外側の変数でnilのままになることがある
		1. 選択肢1:内側のブロックで一時変数を使用する
		1. 選択肢2:内側のブロックで代入演算子(=)を使用し、errorの変数を作成する。
2. 不必要にネストしたコード
    1. 下記実装ではなくelseを省略した書き方を意識する
```go
if foo() {
	// …
	return true
} else {
	// …
}
```
3. init関数の誤用
    1. エラー管理やテストの観点から静的な設定の定義の目的で使用する。
4. ゲッターとセッターの多様
	1. 将来の必要性を予想できるなら使うことに問題無いが、Goではサポートをしていないので、ゲッターとセッターで埋め尽くすべきではない。
5. インターフェース汚染
	1. 抽象化をすぐに行う必要がなければ始めるべきではない。
		1. 一般的な指針
			1. 共通の振る舞い
			2. 具体的な実装との分離
			3. 振る舞いの制限
6. 生産者側のインタフェース
	1. インターフェース分離の原則からクライアントは自分が使わないメソッドに依存することを強いられるべきではない。インターフェースは消費者側にあるべき。
7. インターフェースを返す
	1. クライアント側がある特定の型の抽象化を使うことを強制されることからGoでは悪い習慣とみなされる
8. anyは何も伝えない
	1. 例えばanyの引数を受け取り、anyを返すメソッドは表現力が欠けている。ドキュメントやコードを読む必要性がある。
	2. 静的型付け言語のGoの利点を失う。
	3. encoding/json パッケージを使用して、JSON形式へのマーシャリングを行う際やSQLクエリのパラメータにおいてanyを使用する。
9. ジェネリクスをいつ使うべきかで混乱する
	1. intはint型に制限されるがチルダ(~)を使用した~intとするとintを基底型とする型に制限する
	2. ジェネリックは型ではなく振る舞いを表す際に有効。sortパッケージのsort.Intsやsort.Float64s
10. 型埋め込みで起こり得る問題点を意識していない
	1. ミューテックスは構造体の中にカプセル化し、外部のクライアントからは見えないようにしたいので、埋め込みフィールドにするべきではない
	2. 埋め込みを使用することでメソッドを再定義する必要がなくなる。
11. 関数オプションパターンを使わない
12. プロジェクトの誤った構成
	1. パッケージ名は短く、簡潔で、表現に富み、慣例的に小文字の単語1つであるべき
13. ユーティリティパッケージの作成
	1. utils、common、baseといった意味のない名前で共有パッケージを作るのは良い考えではない。
14. パッケージ衝突を無視する
	1. redisパッケージを使用してredisという変数を使用する衝突は避けないといけない。
	2. 解決法、別の変数名を使用する
	3. 解決法、インポートの際にエイリアスを使用する
```go
import redisapi "mylib/redis"
```
15. コードのドキュメントが無い
	1. 各コメントは句点で終わる完全な文であるべき
16. リンターを使わない
	1. リンターを使用することでシャドウされた変数を検出することが出来る
17. 8進数リテラルで混乱を招く
	1. Linuxの特定の権限を0644と記述するより0o644とした方が明瞭になる
18. 整数のオーバーフローを無視する
	1. コンパイル時に検出可能な整数のオーバーフローはコンパイルエラーになるが、実行時に整数のオーバーフローやアンダーフローはエラーなどの出力なく発生し、パニックにならない
	2. 1を加算する操作で整数のオーバーフローを検出したい場合、値をmathの定数と比較して検査する
	3. 二つの整数による加算時、乗算時のオーバーフローを検出する場合もそれぞれ検査を行う必要がある
19. 浮動小数点を理解していない
	1. 2つの浮動小数点数を比較する場合、その差が許容範囲内であることを検査する
	2. 加算や減算を行う場合、精度を上げるために同じような桁数の演算をまとめる
	3. 精度を優先し、一連の操作で加算、減算、乗算、除算が必要な場合、乗算と除算を先に行う
20. スライスの長さと容量を理解していない
	1. 長さが容量と等しいスライスに要素を追加すると新たな容量を持つ新たな基底配列が作成され、以前の基底配列からすべての要素がコピーされスライス内のポインタが新たな基底配列に更新される
21. 非効率なスライスの初期化
	1. 長さnに等しい容量を持つ変数を定義しappendする方法と長さを指定して代入する方法では後者の方が早く処理される。しかし、読みやすさは前者の方が優れている。
22. nilスライスと空スライスに混乱する
	1. nilスライスは空スライスでもある。
	2. 関数がスライスを返す場合、他の言語ではnilでないコレクションを返すが、Goでは行うべきではない。nilスライスは割り当てを必要としないから。
	3. 優先するのは(var s []string)
	4. 長さが分かっているスライスを作成する必要がある場合は(s := make([]string, length))を使用する
	5. JSONクライアントではnullと[]を厳格に区別する
23. スライスが空か否かを適切に検査しない
	1. スライスを返す関数を呼び出す際に要素が含まれているか確認する場合、nilか確認をしても、空スライスが返ってくる場合だと意図しない挙動をしてしまう。
	2. 呼び出す関数の実装を制御できない場合は長さを検査することが最良。この場合は空とnilどちらを返しても意味的に違いがあるべきではない
24. スライスのコピーを正しく行わない
	1. copyを使うときコピー先にコピーされる要素の数は2つのスライスの長さの小さいほう
	2. 完全なコピーを行うにはコピー先のスライスの長さがコピー元のスライスの長さ以上の必要がある
25. スライスへのappendによる予期しない副作用
	1. スライスのスライスからappendをすることで、基底が更新されてしまう。これを避けるには完全スライス式を使う。
26. スライスとメモリリーク
	1. 完全スライス式を使用しても、基底配列はメモリ上に残るので、スライスのコピーを作成してリークを防ぐ
	2. ポインタのスライスやポインタフィールドを持つ構造体を扱う場合、コピーの作成かスライス化操作によって除外された要素をnilに設定することでメモリリークを回避出来る
27. 非効率なマップの初期化
	1. マップは内部的には8個のキーバリューで構成されたバケットからなる
	2. スライス同様、マップに含まれる要素数が事前に分かっている場合、初期サイズを指定してマップを作成するべき。
	3. マップを拡大するのは十分な容量を再割り当てし、全ての要素の再配置を行う必要があるため重い計算
28. マップとメモリリーク
	1. マップに要素を追加した後にdeleteで削除を行っても、バケットは保持されている。理由はバケットの数は縮小できないから。
	2. メモリ量を減らす解決方法としては、定期的にマップのコピーを再作成する方法と、ポインタを使用する方法がある。ポインタを使用する場合、バケットを保持する事実は解決しないが、各バケットがポインタのサイズを確保することになる。
29. 値の比較の誤り
	1. 定義した構造体から変数を用意し、お互いを==で比較する。この時フィールドが文字列といった比較可能なもので構成されている場合trueが出力されるが、フィールドに比較不能な型であるスライスが含まれるとコンパイルされない。
	2. 比較不能な型を含む2つの構造体を比較する必要がある場合、reflectパッケージを使用する
	3. しかし、reflect.DeepEqualは遅いので、独自のequalメソッドを実装した方が高速
30. rangeループで要素がコピーされることを無視する
	1. 値変数を使用してループ内で加算処理を行ってもスライス内の要素ではなく値変数だけが変更される。スライス要素を更新したい場合は値変数の代わりにインデックスを使う。
31. rangeループでの引数の評価方法を無視する
	1. rangeループは与えられた式がループの開始前に一度だけ評価される。下記は正常に終了。len(s)式は反復ごとに評価される。下記は終了しない
	2. rangeループで一時変数に代入されるのは配列のコピーになる。反復処理中の更新された値を取得するにはインデックスを使って要素にアクセスするかポインタを使う。
```go
package main

import "fmt"

func main() {
    s := []int{0, 1, 2}

    for range s {
        s = append(s, 10)
    }

    fmt.Println(s)
}
```
```go
package main

import "fmt"

func main() {
    s := []int{0, 1, 2}

    for i := 0; i < len(s); i++ {
        s = append(s, 10)
    }

    fmt.Println(s)
}
```
32. rangeループでポインタ要素を使う影響を無視する
	1. 構造体が大きい場合、コピーを避けるためにポインタを使うことがある。しかし、rangeループでスライスを反復処理すると、要素数に関係なく固定アドレスを持つ単一の変数が作成されるので、同じ構造体を参照してしまう。
	2. 解決方法としてローカル変数を作成する方法とスライス要素を参照するポインタを使用する方法がある
33. マップの反復処理で誤った仮定をする
	1. マップの反復処理の順序については保証はない
	2. 反復処理中にマップに挿入を行うと、コードが予測不可能な出力をする。解決策としてマップのコピーを作成し、そのコピーを更新する
34. break文の仕組みを無視する
	1. ループをswitchやselectと組み合わせて使用する場合、break文はforループを終了させるのではなく内側のswitch文を終了させる。ループからブレイクするにはラベルを定義する
35. ループ内でdeferを使う
	1. ループ内でdeferを呼び出すとすべての呼び出しがスタックされ反復処理の間には実行されない。その結果、ループが終了しない場合、メモリリークを引き起こす。この問題を解決するには反復処理の間に別の関数を導入する
36. ルーンの概念を理解していない
	1. ユニコードは文字集合
	2. ユニコードを1バイトから4バイトの2進数で翻訳するのをエンコーディング
	3. lenを使用するとバイト数が返される。
37. 不正確な文字列の反復
	1. 1バイトでエンコードできない文字を含んだ反復処理の場合、ルーンではなくバイト表示される。
	2. ルーンの数についてはlenではなくunicode/utf8パッケージを使う。
	3. インデックスとルーンにアクセスしたい場合はルーンのスライスに変換してから反復処理する
38. Trim関数の誤用
	1. TrimRight/TrimLeftは集合内の末尾/先頭のルーンを削除する
	2. TrimSuffix/TrimPrefixは指定された接尾辞/接頭辞を削除する
39. 最適化されていない文字列の連結
	1. 文字列を連結する際、スライス全ての文字列要素を反復に使用し、+=演算子で連結すると新たな文字列がメモリから再割り当てされ、性能に影響を与える。
	2. 解決策としてstringパッケージのBuilder構造体を作成し、反復ごとにwriteStringメソッドを呼び出して内部バッファに内容を追加していくことで、メモリ上のコピーを最小限にする
	3. また、上記に加えて、ルーン数ではなくバイト数を取得するlen関数を使用し、string.BuilderのGrowメソッドを呼び出して総バイト数の領域を事前割り当てすると、よりコードが速くなる。最終的な文字列のバイト数が事前に分かっている場合はGrowメソッドで内部バイトスライスを事前に割り当てた方が速い。
40. 無駄な文字列変換
	1. プログラマーは文字列か[]byteのどちらかを使用する場合、文字列を好むが、殆どのI/Oは[]byteで行われる。
	2. 例えば先頭と末尾の空白を取り除く関数を実装する場合、引数と戻り値に文字列を使用すると、[]byteに変換する余計な処理が増えることがある。
	3. これを解決するには文字列を受け取って、文字列を返すのではなく、バイトスライスを操作するようにする
41. 部分文字列とメモリリーク
	1. 下記にてoriginalStringが不要になったとしても、substringがまだ参照しているため、originalString全体がメモリ上に残り続ける可能性がある。同じ基底配列を参照するとメモリリークが発生する可能性がある。
	2. この問題を解決するには部分文字列を[]byteに変換し、再び文字列に変換する。または、strings.Cloneを使用してコピーを作成する。
```go
package main

import "fmt"

func main() {
    originalString := "Hello, World!"
    substring := originalString[0:5]

    fmt.Println(substring)

    // originalStringが不要になったと仮定
    // しかし、substringが元のoriginalStringを参照しているため、メモリリークが発生する可能性がある
}
```
42. どちらのレシーバ型を使うべきかわかっていない
	1. メソッドがレシーバを変更する場合やレシーバーが大きなオブジェクトの場合、レシーバーはポインタ
	2. レシーバーの不変性を強制する場合や変更する必要がない場合、レシーバーは値
43. 名前付き結果パラメータを使わない
	1. 名前付き結果パラメータを使用することで同じ型が複数ある場合にコード読み手の助けになる。
	2. errorパラメータにerrという名前を付けても役に立たないので名前付き結果パラメータを使うべきではない
44. 名前付き結果パラメータによる意図しない副作用
	1. 名前付き結果パラメータはゼロ値で初期化されることを把握しておかないと、代入せずエラーをnilのまま返してしまう
45. nilレシーバを返す
	1. ポインタ変数の初期化はnilで行われるがreturn文に与えられる引数は直接のnilではなくnilポインタとなるので、呼び出し元のerr != nilはtrueになる。これを修正するにはメソッドの最後で変数がnilでないか検査し、nilの場合はnilポインタではなく直接nil値を返す
46. ファイル名を関数の入力として使う
	1. ファイルを読み込む関数を作成する際ファイル名を渡すことは単体テストを書きにくくする為ベストではない。テストケースを網羅するために必要なファイルを作成する必要があり、場合によっては何十ものファイルを作成しないといけない。
	2. 解決方法として引数でio.Readerを受け取るよう実装し、入力元を抽象化する。
	3. 上記のメリット1として、ファイルなのかHTTPリクエストなのかに依らず、関数を再利用できる。
	4. 上記のメリット2として、文字列から単体テストを実装できるため、ファイルを作成する必要が無く、テストの可読性と保守性が向上する
47. deferの引数やレシーバの評価方法を無視している
	1. defer文に与えた関数の引数はすぐに評価されてしまう為、下記では常に空文字で呼び出されてしまう
```go
var status string
defer notify(status)
```
解決策としてポインタを使う方法と関数の呼び出しをクロージャの中で行う方法がある
```go
var status string
defer func() {
  notify(status)
}()
```
48. パニックを発生させる
	1. panicはプログラマーエラーや必須の依存関係をロードできなかったとき、回復不可能な状況でのみ使用
49. エラーをラップすべきときを無視する
	1. クライアントが実装の詳細に依存しないようにするには返されるエラーは%wでラップされたものではなく、%vで変換されたものを使う
50. エラー型を不正確に検査する
	1. %wでエラーをラップした場合、ラップしたエラーが返されるので、型switchを使用してもtrueにならない。よってif文とerrors.Asを使用する
51. エラー値を不正確に検査する
	1. センチネルエラー(グローバル変数として定義されたエラー)を%wとfmt.Errorfでラップした場合、==演算子を使用してもfalseになるでerrors.Isを使う
52. エラーを2度処理する
	1. 1つのエラーに対してログが2行あるのは並行して実行した際に続けて表示されない可能性があるので、エラーは1度だけ処理されるべき
53. エラーを処理しない
	1. err変数に出力を代入せずエラーを無視する場合、保守性の観点から前任の開発者が忘れたのか意図的に行ったのか分からなくなるので、ブランク識別子に代入する
54. deferでエラーを処理しない
	1. deferでerrが既にnilでなければそれを優先して、deferで発生したエラーはログに残す。defer開始時にerrはnilだが、deferの無名関数内でエラーが発生した場合はそれをerrに代入する
55. 並行処理と並列処理を混同する
	1. 同じことを1度に複数回行う並列処理と異なり並行処理は1度に多くを扱う構造に関するもの
56. 並行処理は常に高速であると考える
57. チャネルとミューテックスの使い分けに悩む
	1. 並列ゴルーチンはスライスのような共有資源にアクセスしたり修正したりする必要があるときに同期する必要があるのでミューテックスを使用
	2. 並列ゴルーチンの結果を集約する必要がある場合チャネルを使用
58. 競合問題を理解していない
	1. 例えば初期値0の変数iに2つのゴルーチンが同時にインクリメントした際、両方のゴルーチンが読み込んだ値が0なら結果は2ではなく1になる。
	2. 上記データ競合(複数のゴルーチンが同時に同じメモリ位置にアクセスし、書き込み中である場合に発生)の解決方法として、アトミック操作、ミューテックス、チャネルの使用がある。しかし、複数のゴルーチンがインクリメントを行うのではなく、それぞれ別の値を代入した場合、結果が決定的ではない競合状態が発生する。これを解決するにはチャネルを利用する
	3. 下記実装ではデータ競合が発生しないことが保証される。しかし、バッファの有無によってデータ競合が発生することがある。
```go
i := 0
ch := make(chan struct{})
go func() {
	<-ch
	fmt.Println(i)
}()
i++
close(ch)
```
```go
i := 0
ch := make(chan struct{}, 1)
go func() {
    i = 1
    <-ch
}()
ch <- struct{}{}
fmt.Println(i)
```
```go
i := 0
ch := make(chan struct{})
go func() {
    i = 1
    <-ch
}()
ch <- struct{}{}
fmt.Println(i)
```

59. 作業負荷の種類による並行処理の影響を理解していない
60. Goのコンテキストを誤解する
61. 不適切なコンテキストの伝播
62. ゴルーチンを停止するタイミングを分からずに起動する
63. ゴルーチンとループ変数の扱いに注意しない
64. selectとチャネルを使って、決定的な動作を期待する
65. 通知チャネルを使わない
66. nilチャネルを使っていない
67. チャネルの大きさに迷う
68. 文字列のフォーマットで起こり得る副作用を忘れる
69. appendでデータ競合を生み出す
70. スライスとマップで誤ったミューテックスを使う
71. sync.WaitGroupの誤用
72. sync.Condの存在を忘れている
73. errgroupを使わない
74. syncパッケージの型をコピーする
75. 誤った時間の長さを提供する
	1. 一定の間隔で定期的に処理を行うための仕組みを提供するtime.Ticker型のtime.NewTickerはint64を直接渡すべきではない。1000は1000ナノ秒になる。
76. time.Afterとメモリリーク
77. よくあるJSON処理の間違い
78. よくあるSQLの間違い
79. 一時的な資源をクローズしない
80. HTTPリクエストに応答した後にreturn文を忘れる
	1. err != nilの場合に、http.Errorの後にreturn文を追加しないと、以降の成功処理が行われてしまう。
81. デフォルトのHTTPクライアントとサーバーを使う
82. テストを分類しない
	1. ビルドフラグを用いてファイル単位で単体テストや結合テストを分類できる
	2. 環境変数を用いてテスト単位で単体テストや結合テストを分類できる
	3. ショートモードを用いて実行時間の短いテストと長いテストを区別して実行するテストの種類を決定できる
83. -raceフラグを有効にしない
	1. 並行処理を行うアプリでは-raceフラグを指定してテストを実行することは必須ではないが強く推奨される
	2. -raceを使用するとメモリに大きな影響を与える為、ローカルでのテストやCIといった特定の条件下で使用する必要がある
84. テスト実行モードを使わない
	1. -parallelフラグを使用すると、逐次テスト完了後に並列テストが実行され、実行速度を上げることが可能
	2. -shuffleフラグを使用すると、テストの実行順序をランダムにできる。CI中にテストが失敗した場合はその失敗をローカルで再現したいが、その為には冗長モード-vを有効にすることで、シード値を知ることが可能。
85. テーブル駆動テストを使わない
	1. 文字列から改行接尾辞(\nか\r\n)を削除する関数ではテストが5ケースあり、それぞれに重複処理があるだけでなく、関数名も長くなり読みにくくなる。
	2. 一つのテスト関数に複数のサブテストを含める方法ではマップを反復処理することで、決まりきった部分の繰り返しを避け、変更や追加が容易になる
86. 単体テストでスリープする
	1. 関数内でバックグラウンド処理を行う部分をテストしたい際に数ミリ秒スリープする方法があるが、これはフレーキーテスト(コードを変更していないにもかかわらず成功したり失敗したりするテスト)と呼び、保証されないものになっている。
	2. 解決策として1ミリ秒ごとにスリープし、最大リトライ回数を設定するテストの実装、チャネルを使用する方法の2パターンがある。
87. timeAPIを効率よく使わない
88. テスト用ユーティリティパッケージを使っていない
89. 不正確なベンチマークを書く
90. Goテストの機能を全て使いこなしていない
91. CPUキャッシュを理解していない
92. 偽共有につながる並行コードを書く
93. 命令レベルの並列処理を考慮しない
94. データアラインメントを意識していない
95. スタックとヒープを理解していない
96. 割り当てを減らす方法を知らない
97. インライン展開に頼らない
98. Goの診断ツールを使っていない
99. GCの仕組みを理解していない
100. DockerやKubernetesでGoを実行することによる影響を理解していない

# 『Go言語による並行処理』
- プログラム内での共有リソースに対する排他的なアクセスが必要な場所のことをクリティカルセクションという。インクリメントやif文。
- 並行操作を行っているがその操作は状態を全く進めていないプログラムをライブロックという。
- 並行プロセスが仕事をするのに必要なリソースを取得できない状況をリソース枯渇という。不必要にロックを行うと効率的に仕事ができない
- RWMutex（アールダブリューミューテックス）は、Goプログラミング言語で提供される並列処理を制御するためのミューテックス（Mutex）の一種。"RW"は"Read"（読み取り）と"Write"（書き込み）を表し、RWMutexは同時に複数のゴルーチンが読み取り操作を行うことを可能にし、書き込み操作が行われている際には排他的なアクセスを提供する。これにより、読み取り操作と書き込み操作の両方を安全に管理できる。読み取りロックを取得すると、他のゴルーチンも同時に読み取りロックを取得できる。これにより、同時に複数のゴルーチンがリソースを読み取ることができる。書き込みロックを取得すると、他のゴルーチンは読み取りも書き込みもできなくなる。一度に1つのゴルーチンだけがリソースにアクセスできる。

# 『Go言語による分散サービス』
- オフセット
	- 位置を基準点からの距離で表した値
- プロトコルバッファ
	- データを構造化してシリアライズするためのGoogleが設計した機構。JSONよりも多くの利点がある
- RPC（Remote Procedure Call）
	- 別の環境やコンピュータから関数やプロシージャを呼び出すためのメカニズム。通常、分散されたコンピュータ間でプログラムの機能を呼び出す際に使用される。これにより、クライアントとサーバといった異なるプロセスやコンピュータが相互に通信し、機能を提供・利用することが可能。Procedure 手順、手続き
- gRPC
	- プロトコルバッファと呼ばれるバイナリ形式のデータシリアライゼーションを使用。これにより、効率的でコンパクトなデータのやりとりが可能です。一般的なRPCは通常、JSON や XML などのテキストベースのデータフォーマットを使用。gRPC は通信に HTTP/2 をベースにしており高性能な通信を実現している。一般的なRPCは通常、HTTP/1.x などのバージョンをベースにしている。
- HTTP/2
	- HTTPの新規格
- curlコマンドのオプション
	- -X: HTTPメソッドの指定
	- -d: リクエストデータの指定
```bash
curl -X POST -d "name=John&age=30" http://example.com/users
```
- gRPCの開発は、まずProtocol Buffers（proto）ファイルにサービスとメッセージを定義し、それをコンパイルしてgRPC用のコードを生成するというステップ。
- syntax ディレクティブ
	- syntax = "proto3"; などと記述され、使用する Protocol Buffers の構文バージョンを指定。最新のバージョンは proto3
- message キーワード
	- メッセージ型はデータ構造を定義する為のもの。下記はPerson メッセージ型を定義。
	- また、Protocol Buffersにおける、メッセージのバイナリ表現において各フィールドを識別するために、番号が必要。名前だけではなく、番号がフィールドのバイナリ表現での位置を示す。
```go
message Person {
    string name = 1;
    int32 id = 2;
}
```
- service キーワード:
	- メソッドを定義する。メソッドにはリクエスト型とレスポンス型を指定する

# その他
- Javaの publicや package-private に似た２つのアクセスレベルがGoには存在する。トップレベルで宣言された 2変数や関数の名前が大文字で始まる場合は public 、小文字で始まる場合は package-private のアクセスレベルになる。
- constは変数と異なり、使われない場合でもコンパイルエラーにならない。
    - constはbool、int/int32/int64といった数値、複素数、文字列を宣言することができる。スライスや配列、structの値は宣言できない。
    - 変数の場合、xを使う際はfloat64(x)でキャストしなければなりませんでしたが、constで宣言されたxは型を明示しておらず、使われ方によって型が自動的に決定される
- switch文で明示的に次のcaseに降下したい場合はfallthroughを使う
- 関数
    - 特定の型に属さない独立した手続き
    - funcキーワードで宣言
- メソッド
    - 特定の型に紐づいた関数で、その型のインスタンスに対して操作を行う
    - funcキーワードに加えて、レシーバを指定
- 値型
    - int、float64、bool、string、struct などがある
    - 変数間の代入が行われると、値がコピーされる。
- 参照型
    - slice、map、chan、pointer、interface などがあります。
    - 変数間の代入が行われると、ポインタがコピーされ、同じオブジェクトを参照
- UnicodeはASCIIや全角文字など、様々な文字を包括している
- rune型はUnicode文字を表現するための型
- エンコードは、文字列やデータをバイト列に変換するプロセス
- Go言語では、UTF-8エンコーディングが標準的なエンコーディング方式
- ビルトイン関数は、プログラミング言語の中で組み込まれている基本的な機能
- ポインタレシーバを使用する2つの理由
    - メソッドがレシーバが指す先の変数を変更するため
    - メソッドの呼び出し毎に変数のコピーによる無駄なメモリ使用と処理を避けるため
- 関数も変数。他変数のように関数を渡すことが可能
- クロージャ
    - 無名関数を作成して変数に代入すること
- シグニチャは、その関数やメソッドが受け取る引数の型や数、および返り値の型
- 型アサーションはインターフェース型の値から具体的な型への変換を行う手法
- Go言語では、関数に引数として渡された変数は、値渡しがデフォルト。これは、引数として渡された変数のコピーが関数内で作成され、関数内での変更がコピーされた変数に影響を与えるだけで、元の変数には影響を与えないという動作。この特性は、関数内での変更が関数外の変数に影響を及ぼさないようにするため。関数内で引数の値を変更し、その変更が関数外の変数に反映されるようにしたい場合は、ポインタを使って引数を渡すことが必要。
- 構造体(struct)はJavaでいうところのクラスに該当する。
    - Goの構造体はメソッドをメンバに含めることはできない。
    - 変数のみを構造体のメンバに含めることができる。
- 条件のないswitchは、 switch true と書くことと同じ
    - このswitchの構造は、長くなりがちな "if-then-else" のつながりをシンプルに表現できます。
- deferへ渡した関数が複数ある場合、その呼び出しはスタック(stack)される。
    - 呼び出し元の関数がreturnするとき、 defer へ渡した関数は LIFO(last-in-first-out) の順番で実行される
- スライスはどんなデータも格納しておらず、単に元の配列の部分列を指し示している。
- スライスの要素を変更すると、その元となる配列の対応する要素が変更される。
- 同じ元となる配列を共有している他のスライスは、それらの変更が反映される。
- mapのキーに[]byte型を指定することは不可能。理由はスライスが可変長であり、値が同じでもポインタが異なるから。
- Goの1.18以降ではインタフェース型にメソッドの集合だけでなく、型定義が可能。
- スライス作成時の開始位置、終了位置によって容量は異なる
[2:] (スライスの開始位置を指定してスライスを作成):
```go
package main

import "fmt"

func main() {
    s := []int{1, 2, 3, 4, 5}

    // スライスの開始位置を指定して新しいスライスを作成
    sliced := s[2:]

    fmt.Printf("s: len=%d, cap=%d\n", len(s), cap(s))
    fmt.Printf("sliced: len=%d, cap=%d\n", len(sliced), cap(sliced))
}
```
結果:
```go
s: len=5, cap=5
sliced: len=3, cap=3
```
[:2] (スライスの終了位置を指定してスライスを作成):
```go
package main

import "fmt"

func main() {
    s := []int{1, 2, 3, 4, 5}

    // スライスの終了位置を指定して新しいスライスを作成
    sliced := s[:2]

    fmt.Printf("s: len=%d, cap=%d\n", len(s), cap(s))
    fmt.Printf("sliced: len=%d, cap=%d\n", len(sliced), cap(sliced))
}
```
結果:
```go
s: len=5, cap=5
sliced: len=2, cap=5
```
- 下記元のスライス s の要素数は 5 であり、スライス sliced の範囲は 1 から 3 までの要素を含むため、容量は 5 - 1 = 4 となる。ここで、-1 は開始位置が 1 であるため、その分を考慮している。したがって、sliced の容量は 4 になります。
```go
s := []int{1, 2, 3, 4, 5}
sliced := s[1:4]
```
- チャネルからのデータ受信を単に待ち受ける場合、変数に代入する必要は無い。下記はチャネルchからデータを受信し、そのデータを特定の変数に代入しないで無視している。このような使い方は、チャネルにデータが到着するのを待ち、データ自体は使用しない場合に役立つ。例えば、ゴルーチン同士の同期をとる場合、他のゴルーチンが特定のイベントが発生したことを通知するためにチャネルを使用することがある。このとき、データは不要で、通知自体が重要な場合に、この形式が使われる。
```go
<-ch
```
- アドレスはメモリ上の場所を示す数値であり、ポインタはそのアドレスを保持する変数
- ヒープは主に動的に割り当てられたメモリを指す。ヒープはプログラム実行中に必要に応じてメモリを確保し、使用が終わったら解放される。Goでは、newやmakeなどの組み込み関数を使用してヒープ上にメモリを割り当てることがある。ヒープ上のメモリはガベージコレクションによって管理され、不要なメモリは自動的に解放される。