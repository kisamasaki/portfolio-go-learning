# 『初めてのGo言語』
- goはコンパイル言語
    - バイナリファイルが作られる
    - go runコマンドで一時ディレクトリに置かれ、プログラム終了後に削除される
- コンパイルのメリット
    - 機械語やバイナリコードに変換して実行可能なプログラムを生成
    - 型の不一致に起因するエラーをコンパイル時に検出可能
    - 機械語に変換されているため、通常は高い実行速度を提供する
- パッケージ
    - 関連するソースコードがまとめられたファイルの集まり
- モジュール
    - プロジェクトの依存関係を管理し、コードのバージョン管理を補助する仕組み
    - go.mod ファイルによって定義され、バージョンなどの情報が記述されている
- 依存関係
    - 外部ライブラリやモジュールに対するプロジェクトの依存性
- 配列には制限があるため直接使われることは多くない
- 一連の値を保持する為のデータ構造が必要ならば殆どの場合可変長の配列とも言えるスライスを使うのが正解
- go言語は値呼び出しの言語
    - 関数に渡される引数が実際にはその値のコピーが渡されることを意味する。関数内で引数の値を変更しても、呼び出し元の変数には影響がない。
- appendを使用した場合、元のスライスが参照している配列の容量が足りない場合、新しいメモリ領域が確保され、既存の要素と新しい要素が新しいメモリにコピーされる。この操作によって元のスライスが更新されるのではなく、新しいスライスが新しいメモリを指すようになります。
- appendの戻り値を変数に代入せず無視するとコンパイル時にエラー
- capはスライスの現在のキャパシティを返す。新しいデータを保持するのに十分なサイズがあるか確認したい場合はcapが使える
- appendによってスライスが大きくなってくるとコピーの為に時間がかかるようになる。予め最大のサイズが分かっているならばmakeを指定した方が効率的
- appendを使用してスライスに要素を追加した際、元の配列が不要になる場合、ガベージコレクタがそれを検出してメモリを解放します。
- スライスからサブスライスを切り出すときは注意する必要がある。親スライスもサブスライスも同じメモリ領域を共有し一方の変更はもう一方に影響を及ぼす。サブスライスを作ったらオリジナルのスライスもサブスライスも変更は避けた方が無難。appendでは複数のスライスがキャパシティを共有しないようフルスライス式を使う。
- スライスマップは参照型
- 確実にリソース解放を行う為にdeferを使用できるが、Close()といったエラーを返す可能性があるケースもある。無名関数を使用し、名前付きの返り値に代入すると呼び出し元に返すことが可能。
```go
package main

import (
	"fmt"
	"io"
	"os"
)

func deferReturnSample(fname string) (err error) {
	var f *os.File
	f, err = os.Create(fname)
	if err != nil {
		return fmt.Errorf("ファイルオープンのエラー: %w", err)
	}

	// defer文内で即時エラーチェックと関数終了を行う無名関数を使用
	defer func() {
		closeErr := f.Close()
		if closeErr != nil && err == nil {
			// ファイルクローズのエラーが発生し、かつまだエラーが発生していない場合
			err = fmt.Errorf("ファイルクローズのエラー: %w", closeErr)
		}
	}()

	_, writeErr := io.WriteString(f, "deferのエラーを拾うサンプル")
	if writeErr != nil {
		// 書き込みエラーが発生した場合、即座に関数終了
		return fmt.Errorf("ファイル書き込みエラー: %w", writeErr)
	}

	return nil
}

func main() {
	err := deferReturnSample("example.txt")
	if err != nil {
		fmt.Println("エラーが発生しました:", err)
		return
	}

	fmt.Println("ファイルの書き込みとクローズが正常に行われました.")
}
```

# 『実用Go言語』
- Goのアプリケーションとライブラリはそれぞれモジュールと呼ばれる塊になっており、1つのフォルダが1つのモジュール
- iotaの値はコンパイル時に決まる為、途中で新しく要素が挿入されると値が変わる
    - 末尾以外に追加すると名前に対応する整数値がそれまでと変わる
- Go言語では、構造体を使用して関数にオプション引数を渡す柔軟な方法がある
    - 関数の引数が構造体である場合、未指定のフィールドはその型のゼロ値に初期化される

# 『Go言語プログラミングエッセンス』
```go
n := 50
a = append(a[:n], a[n+1:]...)

n := 50
a = a[:n+copy(a[n:], a[n+1:])]
```
- スライスから要素を削除する場合はappendを使う方法、部分参照とcopyを使う方法がある。
appendを使う場合はアロケーション(新しいメモリ領域の割り当て)が発生する。
- copyを使用して元のスライス内でデータを前に詰める操作は既存のメモリ内で行われ、新しいメモリが確保されることは無い。
- Goの文字列はイミュータブルなので、一度文字列が作成されると、その内容を直接変更することはできない
    - 文字列を変更しようとすると、新しい文字列が作成され、変数がそれを参照するようになる
    - この際、元の文字列のメモリは解放されない。代わりに、新しい文字列が別のメモリ領域に確保され、変数がそのメモリ領域を指すようになる
    - バイトスライス（[]byte型）はミュータブルで、その内容を変更することができる。文字列からバイトスライスへの変換を通じて、バイトスライスを変更すると、元の文字列が指しているメモリ領域そのものが変更される
- 配列からスライスに変換するには、Go言語の組み込み関数である [:] を使用
- mapは順序を保持しない為for-rangeは毎回異なる結果となる
    - ソートされたキーで列挙したい場合は先にsort.Stringsを使用する必要がある
- 構造体のフィールドに他のパッケージから参照するには先頭を大文字にする必要がある。
    - encoding/jsonにもこのルールが適用される為、JSONに小文字は適用されない
    - 関数の引数にstructのデータを渡すとコピーが行われるので、コピーのオーバーヘッドを避けるにはポインタを使用する

# 『Go言語100Tips』










# その他

- constは変数と異なり、使われない場合でもコンパイルエラーにならない。
    - constはbool、int/int32/int64といった数値、複素数、文字列を宣言することができる。スライスや配列、structの値は宣言できない。
    - 変数の場合、xを使う際はfloat64(x)でキャストしなければなりませんでしたが、constで宣言されたxは型を明示しておらず、使われ方によって型が自動的に決定される
- switch文で明示的に次のcaseに降下したい場合はfallthroughを使う
- 関数
    - 特定の型に属さない独立した手続き
    - funcキーワードで宣言
- メソッド
    - 特定の型に紐づいた関数で、その型のインスタンスに対して操作を行う
    - funcキーワードに加えて、レシーバを指定
- 値型
    - int、float64、bool、string、struct などがある
    - 変数間の代入が行われると、値がコピーされる。
- 参照型
    - slice、map、chan、pointer、interface などがあります。
    - 変数間の代入が行われると、ポインタがコピーされ、同じオブジェクトを参照
- UnicodeはASCIIや全角文字など、様々な文字を包括している
- rune型はUnicode文字を表現するための型
- エンコードは、文字列やデータをバイト列に変換するプロセス
- Go言語では、UTF-8エンコーディングが標準的なエンコーディング方式
- ビルトイン関数は、プログラミング言語の中で組み込まれている基本的な機能
- ポインタレシーバを使用する2つの理由
    - メソッドがレシーバが指す先の変数を変更するため
    - メソッドの呼び出し毎に変数のコピーによる無駄なメモリ使用と処理を避けるため
- 関数も変数。他変数のように関数を渡すことが可能
- クロージャ
    - 無名関数を作成して変数に代入すること
- シグニチャは、その関数やメソッドが受け取る引数の型や数、および返り値の型
- 型アサーションはインターフェース型の値から具体的な型への変換を行う手法
- Go言語では、関数に引数として渡された変数は、値渡しがデフォルト。これは、引数として渡された変数のコピーが関数内で作成され、関数内での変更がコピーされた変数に影響を与えるだけで、元の変数には影響を与えないという動作。この特性は、関数内での変更が関数外の変数に影響を及ぼさないようにするため。関数内で引数の値を変更し、その変更が関数外の変数に反映されるようにしたい場合は、ポインタを使って引数を渡すことが必要。
- 構造体(struct)はJavaでいうところのクラスに該当する。
    - Goの構造体はメソッドをメンバに含めることはできない。
    - 変数のみを構造体のメンバに含めることができる。
- 条件のないswitchは、 switch true と書くことと同じ
    - このswitchの構造は、長くなりがちな "if-then-else" のつながりをシンプルに表現できます。
- deferへ渡した関数が複数ある場合、その呼び出しはスタック(stack)される。
    - 呼び出し元の関数がreturnするとき、 defer へ渡した関数は LIFO(last-in-first-out) の順番で実行される
- スライスはどんなデータも格納しておらず、単に元の配列の部分列を指し示している。
- スライスの要素を変更すると、その元となる配列の対応する要素が変更される。
- 同じ元となる配列を共有している他のスライスは、それらの変更が反映される。