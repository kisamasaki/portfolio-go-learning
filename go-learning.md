# 『初めてのGo言語』
- goはコンパイル言語
    - バイナリファイルが作られる
    - go runコマンドで一時ディレクトリに置かれ、プログラム終了後に削除される
- コンパイルのメリット
    - 機械語やバイナリコードに変換して実行可能なプログラムを生成
    - 型の不一致に起因するエラーをコンパイル時に検出可能
    - 機械語に変換されているため、通常は高い実行速度を提供する
- パッケージ
    - 関連するソースコードがまとめられたファイルの集まり
- モジュール
    - プロジェクトの依存関係を管理し、コードのバージョン管理を補助する仕組み
    - go.mod ファイルによって定義され、バージョンなどの情報が記述されている
- 依存関係
    - 外部ライブラリやモジュールに対するプロジェクトの依存性
- 配列には制限があるため直接使われることは多くない
- 一連の値を保持する為のデータ構造が必要ならば殆どの場合可変長の配列とも言えるスライスを使うのが正解
- go言語は値呼び出しの言語
    - 関数に渡される引数が実際にはその値のコピーが渡されることを意味する。関数内で引数の値を変更しても、呼び出し元の変数には影響がない。
- appendを使用した場合、元のスライスが参照している配列の容量が足りない場合、新しいメモリ領域が確保され、既存の要素と新しい要素が新しいメモリにコピーされる。この操作によって元のスライスが更新されるのではなく、新しいスライスが新しいメモリを指すようになります。
- appendの戻り値を変数に代入せず無視するとコンパイル時にエラー
- capはスライスの現在のキャパシティを返す。新しいデータを保持するのに十分なサイズがあるか確認したい場合はcapが使える
- appendによってスライスが大きくなってくるとコピーの為に時間がかかるようになる。予め最大のサイズが分かっているならばmakeを指定した方が効率的
- appendを使用してスライスに要素を追加した際、元の配列が不要になる場合、ガベージコレクタがそれを検出してメモリを解放します。
- スライスからサブスライスを切り出すときは注意する必要がある。親スライスもサブスライスも同じメモリ領域を共有し一方の変更はもう一方に影響を及ぼす。サブスライスを作ったらオリジナルのスライスもサブスライスも変更は避けた方が無難。appendでは複数のスライスがキャパシティを共有しないようフルスライス式を使う。
- スライスマップは参照型
- スライスxをスライスして別のスライスyを作ると、スライスxで使われていなかったキャパシティもスライスyと共有されてしまう。
    - この場合、複数のスライスが他のスライスのデータをappendしたり上書きする。
    - こうした状況を避けるにはサブスライスのキャパシティとサブスライスの長さを同じにすることで、要素追加時に他のスライスと共有無しに新しいスライスを作ることが可能。
- オリジナルとはメモリを共有しない独立したスライスを生成する必要があるのならばmakeと組み込みの関数copyを使う。
- Go言語では文字列を関数lenに渡して文字列の長さが返されるが値はバイト数になる。
```go
// 要素を加えることが出来ない
var nilMap map[string]int

// 読み書き療法可能
totalWins := map[string]int{}
```
- Goではifの本体は短くすることが推奨される
```go
package main

import "fmt"

func main() {
	for i := 1; i <= 100; i++ {
		if i%3 == 0 {
			if i%5 == 0 {
				fmt.Println(i, "3でも5でも割り切れる")
			} else {
				fmt.Println(i, "3で割り切れる")
			}
		} else if i%5 == 0 {
			fmt.Println(i, "5で割り切れる")
		} else {
			fmt.Println(i)
		}
	}
}
```
上記ではなく下記の書き方を行う。
```go
package main

import "fmt"

func main() {
	for i := 1; i <= 100; i++ {
		if i%3 == 0 && i%5 == 0 {
			fmt.Println(i, "3でも5でも割り切れる")
			continue
		}
		if i%3 == 0 {
			fmt.Println(i, "3で割り切れる")
			continue
		}
		if i%5 == 0 {
			fmt.Println(i, "5で割り切れる")
			continue
		}
		fmt.Println(i)
	}
}
```
- for-rangeを使用してイテレーションする場合、通常は要素のコピーが作成される。
```go
numbers := []int{1, 2, 3, 4, 5}

for _, num := range numbers {
    num *= 2  // numは元の要素のコピー
    fmt.Println(num)
}

fmt.Println(numbers)  // 元のスライスは変わっていない
```
元のスライスの要素自体を変更したい場合は、添え字を使って直接要素にアクセスするか、ポインタを使用して要素への参照を取得して操作する必要がある
```go
numbers := []int{1, 2, 3, 4, 5}

for i := range numbers {
    numbers[i] *= 2  // numbers[i]は元の要素への参照
}

fmt.Println(numbers)  // 元のスライスが変更されている
```
- ラベルを使用した場合、breakでは外側のforループが一気に終了し、continueを使用した場合、内側のforループがスキップされ、外側のforループの次の繰り返しに進む。
- for-rangeで最初の2番目から最後の2番目まで処理したい場合は、continueやbreakを使用するよりも下記の方が短くて理解しやすい
```go
package main

import "fmt"

func main() {
	evenVals := []int{2, 4, 6, 8, 10}
	for i := 1; i < len(evenVals)-1; i++ {
		fmt.Println(i, evenVals[i])
	}
}
```
- 名前付き戻り値はdeferで使用する。プログラムの説明になるという理由で好まれる場合もあるが、関数の外側でも変数が使われる場合に可読性が低下する。
- 関数が値を返すならブランクreturnは絶対に使ってはならない。返される値が分かりにくくなるから。
- Goにはカンマokイディオムがあり、下記実装で値と真偽値が返る。
```go
v, ok := m["hello"]
```
- "ダックタイピング" という用語は、「もしアヒルのように歩いて、鳴いて、アヒルのように見えるなら、それはアヒルだ」というアナロジーに由来している。具体的な型の名前よりも、その型の振る舞いが重要であるという考え方。型の名前に依存せず、代わりに振る舞いに焦点を当てるため、柔軟性がある
```go
package main

import "fmt"

// Quacker インターフェース
type Quacker interface {
	Quack()
}

// Duck 型
type Duck struct{}

// Duck 型が Quacker インターフェースを実装
func (d Duck) Quack() {
	fmt.Println("Quack!")
}

// Dog 型
type Dog struct{}

// Dog 型が Quacker インターフェースを実装
func (d Dog) Quack() {
	fmt.Println("Woof!")
}

func makeSomeNoise(q Quacker) {
	q.Quack()
}

func main() {
	duck := Duck{}
	dog := Dog{}

	makeSomeNoise(duck) // Duck 型は Quacker インターフェースを実装している
	makeSomeNoise(dog)  // Dog 型も Quacker インターフェースを実装している
}
```
- *を用いてそのポインタが参照するアドレスに保存されている値を返すことをデリファレンスと呼ぶ
- nilポインタをデリファレンスしようとするとパニックにあるのでnilでないことを確認する必要がある。
- 基本型のポイントが必要な場合はまず基本型の変数を宣言し、それから参照するポインタ変数を宣言する
```go
var y string
z := &y
```
下記構造体のフィールドに直接代入は出来ないので、回避するには変数を作る必要がある。
```go
	type person struct {
		FirstName  string
		MiddleName *string
		LastName   string
	}
	
	p := person{
		FirstName:  "Pat",
		MiddleName: "Perry",  // ←コンパイル時のエラー
		LastName:   "Peterson",
	}
```
または下記ポインタ型を返却する関数を実装する。
```go
func stringp(s string) *string {
    return &s
}
```
- 定数（const）と型（type）はコンパイル時にのみ存在し、実行時にはメモリアドレスを持たない。これらはコンパイル時に解決され、実行時にはメモリ上に配置される必要が無い。
```go
const Pi = 3.14159
```
```go
type MyInt int
```
- ポインタとしてnilを渡した場合、その値をnil以外に変えることは出来ない。
- 関数にメモリのアドレスを渡した場合、そのアドレスを変えることは出来ない。
- ファイルの読み取りでforを用いてバッファとしてスライスを使う場合、一度だけバッファとして使うスライスを作成するのではなく、都度新しいスライスを作成してしまうと、メモリの割り当てと解放が頻繁に発生し、非効率的な動作となる。
- Go言語は下記のようなオーバーロードは許容されない
```go
// これはGoでは許容されない
func add(a, b int) int {
    return a + b
}

func add(a, b float64) float64 {
    return a + b
}
```
- 埋め込みフィールドは、型に別の型に埋め込むこと
    - 埋め込みフィールドで宣言されているフィールドやメソッドはそれを埋め込んでいる上位の構造体に「昇格」し、その構造体から直接呼び出せる。
    - 同名のフィールドやメソッドがある場合は埋め込まれている方が隠されるので、埋め込まれているフィールドの型を明示する必要がある
```go
type Inner struct {
	X int
}

type Outer struct {
	Inner
	X int
}

func main() {
	o := Outer{
		Inner: Inner{
			X: 10,
		},
		X: 20,
	}
	fmt.Println(o.X)       // 20
	fmt.Println(o.Inner.X) // 10
}
```
- C#ではインターフェースをクラスに明示的に実装を宣言するが、Go言語ではインターフェースが暗黙的に実装される。
    - C#ではインターフェースを実装するクラスはその実装を明示的に宣言し、具体的なメソッドがどのように実装されているかが分かる。
    - この明示性により、クラスの実装やインターフェースの使用がより透明になる。
    - C#では既存のクラスに新しいメソッドを追加する場合、そのクラスを変更する必要があるが、Goでは既存のクラスを変更することなく新しい機能を追加できる。
# 『実用Go言語』
- Goのアプリケーションとライブラリはそれぞれモジュールと呼ばれる塊になっており、1つのフォルダが1つのモジュール
- iotaの値はコンパイル時に決まる為、途中で新しく要素が挿入されると値が変わる
    - 末尾以外に追加すると名前に対応する整数値がそれまでと変わる
- Go言語では、構造体を使用して関数にオプション引数を渡す柔軟な方法がある
    - 関数の引数が構造体である場合、未指定のフィールドはその型のゼロ値に初期化される
- 確実にリソース解放を行う為にdeferを使用できるが、Close()といったエラーを返す可能性があるケースもある。無名関数を使用し、名前付きの返り値に代入すると呼び出し元に返すことが可能。
```go
package main

import (
	"fmt"
	"io"
	"os"
)

func deferReturnSample(fname string) (err error) {
	var f *os.File
	f, err = os.Create(fname)
	if err != nil {
		return fmt.Errorf("ファイルオープンのエラー: %w", err)
	}

	// defer文内で即時エラーチェックと関数終了を行う無名関数を使用
	defer func() {
		closeErr := f.Close()
		if closeErr != nil && err == nil {
			// ファイルクローズのエラーが発生し、かつまだエラーが発生していない場合
			err = fmt.Errorf("ファイルクローズのエラー: %w", closeErr)
		}
	}()

	_, writeErr := io.WriteString(f, "deferのエラーを拾うサンプル")
	if writeErr != nil {
		// 書き込みエラーが発生した場合、即座に関数終了
		return fmt.Errorf("ファイル書き込みエラー: %w", writeErr)
	}

	return nil
}

func main() {
	err := deferReturnSample("example.txt")
	if err != nil {
		fmt.Println("エラーが発生しました:", err)
		return
	}

	fmt.Println("ファイルの書き込みとクローズが正常に行われました.")
}
```

# 『Go言語プログラミングエッセンス』
```go
n := 50
a = append(a[:n], a[n+1:]...)

n := 50
a = a[:n+copy(a[n:], a[n+1:])]
```
- スライスから要素を削除する場合はappendを使う方法、部分参照とcopyを使う方法がある。
appendを使う場合はアロケーション(新しいメモリ領域の割り当て)が発生する。
- copyを使用して元のスライス内でデータを前に詰める操作は既存のメモリ内で行われ、新しいメモリが確保されることは無い。
- Goの文字列はイミュータブルなので、一度文字列が作成されると、その内容を直接変更することはできない
    - 文字列を変更しようとすると、新しい文字列が作成され、変数がそれを参照するようになる
    - この際、元の文字列のメモリは解放されない。代わりに、新しい文字列が別のメモリ領域に確保され、変数がそのメモリ領域を指すようになる
    - バイトスライス（[]byte型）はミュータブルで、その内容を変更することができる。文字列からバイトスライスへの変換を通じて、バイトスライスを変更すると、元の文字列が指しているメモリ領域そのものが変更される
- 配列からスライスに変換するには、Go言語の組み込み関数である [:] を使用
- mapは順序を保持しない為for-rangeは毎回異なる結果となる
    - ソートされたキーで列挙したい場合は先にsort.Stringsを使用する必要がある
- 構造体のフィールドに他のパッケージから参照するには先頭を大文字にする必要がある。
    - encoding/jsonにもこのルールが適用される為、JSONに小文字は適用されない
    - 関数の引数にstructのデータを渡すとコピーが行われるので、コピーのオーバーヘッドを避けるにはポインタを使用する
- iotaを使用する際、一つのconstにまとめて記述を行うと初期値が連続するため、型ごとに宣言を別にする必要がある
- 下記実装だと、出力する際には既にループが終了している可能性があるので意図通りの結果が得られない。
```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var wg sync.WaitGroup

	for i := 0; i < 3; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			fmt.Println(i)
		}()
	}

	wg.Wait()
}
```
これを修正するためには、各ゴルーチンが異なる i の値を参照できるよう実装する。
```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var wg sync.WaitGroup

	for i := 0; i < 3; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			fmt.Println(i)
		}(i)
	}

	wg.Wait()
}
```
下記実装の場合、iの最終的な値を参照してしまう可能性がある。この問題を解決するには、iを引数として generateLargeValueに渡すことで、各ゴルーチンが異なるiの値を処理できるようにする。
```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	var wg sync.WaitGroup

	for i := 0; i < 3; i++ {
		wg.Add(1)
		go func() {
			largeValue := generateLargeValue(i) // 時間のかかる処理を含む関数
			defer wg.Done()
			fmt.Println(largeValue)
		}()
	}

	wg.Wait()
}

func generateLargeValue(i int) int {
	// 仮に時間のかかる処理を含む関数
	time.Sleep(1 * time.Second)
	return i
}

```

# 『Go言語100Tips』

# その他
- Javaの publicや package-private に似た２つのアクセスレベルがGoには存在する。トップレベルで宣言された 2変数や関数の名前が大文字で始まる場合は public 、小文字で始まる場合は package-private のアクセスレベルになる。
- constは変数と異なり、使われない場合でもコンパイルエラーにならない。
    - constはbool、int/int32/int64といった数値、複素数、文字列を宣言することができる。スライスや配列、structの値は宣言できない。
    - 変数の場合、xを使う際はfloat64(x)でキャストしなければなりませんでしたが、constで宣言されたxは型を明示しておらず、使われ方によって型が自動的に決定される
- switch文で明示的に次のcaseに降下したい場合はfallthroughを使う
- 関数
    - 特定の型に属さない独立した手続き
    - funcキーワードで宣言
- メソッド
    - 特定の型に紐づいた関数で、その型のインスタンスに対して操作を行う
    - funcキーワードに加えて、レシーバを指定
- 値型
    - int、float64、bool、string、struct などがある
    - 変数間の代入が行われると、値がコピーされる。
- 参照型
    - slice、map、chan、pointer、interface などがあります。
    - 変数間の代入が行われると、ポインタがコピーされ、同じオブジェクトを参照
- UnicodeはASCIIや全角文字など、様々な文字を包括している
- rune型はUnicode文字を表現するための型
- エンコードは、文字列やデータをバイト列に変換するプロセス
- Go言語では、UTF-8エンコーディングが標準的なエンコーディング方式
- ビルトイン関数は、プログラミング言語の中で組み込まれている基本的な機能
- ポインタレシーバを使用する2つの理由
    - メソッドがレシーバが指す先の変数を変更するため
    - メソッドの呼び出し毎に変数のコピーによる無駄なメモリ使用と処理を避けるため
- 関数も変数。他変数のように関数を渡すことが可能
- クロージャ
    - 無名関数を作成して変数に代入すること
- シグニチャは、その関数やメソッドが受け取る引数の型や数、および返り値の型
- 型アサーションはインターフェース型の値から具体的な型への変換を行う手法
- Go言語では、関数に引数として渡された変数は、値渡しがデフォルト。これは、引数として渡された変数のコピーが関数内で作成され、関数内での変更がコピーされた変数に影響を与えるだけで、元の変数には影響を与えないという動作。この特性は、関数内での変更が関数外の変数に影響を及ぼさないようにするため。関数内で引数の値を変更し、その変更が関数外の変数に反映されるようにしたい場合は、ポインタを使って引数を渡すことが必要。
- 構造体(struct)はJavaでいうところのクラスに該当する。
    - Goの構造体はメソッドをメンバに含めることはできない。
    - 変数のみを構造体のメンバに含めることができる。
- 条件のないswitchは、 switch true と書くことと同じ
    - このswitchの構造は、長くなりがちな "if-then-else" のつながりをシンプルに表現できます。
- deferへ渡した関数が複数ある場合、その呼び出しはスタック(stack)される。
    - 呼び出し元の関数がreturnするとき、 defer へ渡した関数は LIFO(last-in-first-out) の順番で実行される
- スライスはどんなデータも格納しておらず、単に元の配列の部分列を指し示している。
- スライスの要素を変更すると、その元となる配列の対応する要素が変更される。
- 同じ元となる配列を共有している他のスライスは、それらの変更が反映される。